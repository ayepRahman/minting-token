{"ast":null,"code":"import { useCallbackRef, useControllableProp } from \"@chakra-ui/hooks\";\nimport { clampValue, countDecimalPlaces, maxSafeInteger, minSafeInteger, toPrecision } from \"@chakra-ui/utils\";\nimport { useCallback, useState } from \"react\";\nexport function useCounter(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    keepWithinRange = true\n  } = props;\n  var onChangeProp = useCallbackRef(onChange);\n  var [valueState, setValue] = useState(() => {\n    var _cast;\n\n    if (defaultValue == null) return \"\";\n    return (_cast = cast(defaultValue, stepProp, precisionProp)) != null ? _cast : \"\";\n  });\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n\n  var [isControlled, value] = useControllableProp(valueProp, valueState);\n  var decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  var precision = precisionProp != null ? precisionProp : decimalPlaces;\n  var update = useCallback(next => {\n    if (next === value) return;\n\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n\n    onChangeProp == null ? void 0 : onChangeProp(next.toString(), parse(next));\n  }, [onChangeProp, isControlled, value]); // Function to clamp the value and round it to the precision\n\n  var clamp = useCallback(value => {\n    var nextValue = value;\n\n    if (keepWithinRange) {\n      nextValue = clampValue(nextValue, min, max);\n    }\n\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  var increment = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next;\n    /**\n     * Let's follow the native browser behavior for\n     * scenarios where the input starts empty (\"\")\n     */\n\n    if (value === \"\") {\n      /**\n       * If `min` is set, native input, starts at the `min`.\n       * Else, it starts at `step`\n       */\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  var decrement = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next; // Same thing here. We'll follow native implementation\n\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  var reset = useCallback(() => {\n    var next;\n\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      var _cast2;\n\n      next = (_cast2 = cast(defaultValue, stepProp, precisionProp)) != null ? _cast2 : min;\n    }\n\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update, min]);\n  var castValue = useCallback(value => {\n    var _cast3;\n\n    var nextValue = (_cast3 = cast(value, stepProp, precision)) != null ? _cast3 : min;\n    update(nextValue);\n  }, [precision, stepProp, update, min]);\n  var valueAsNumber = parse(value);\n  /**\n   * Common range checks\n   */\n\n  var isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  var isAtMax = valueAsNumber === max;\n  var isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue\n  };\n}\n\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\n\nfunction getDecimalPlaces(value, step) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));\n}\n\nfunction cast(value, step, precision) {\n  var parsedValue = parse(value);\n  if (Number.isNaN(parsedValue)) return undefined;\n  var decimalPlaces = getDecimalPlaces(parsedValue, step);\n  return toPrecision(parsedValue, precision != null ? precision : decimalPlaces);\n}","map":{"version":3,"sources":["/Users/arifrahman/Code/personal/minting-token/client/node_modules/@chakra-ui/counter/dist/esm/use-counter.js"],"names":["useCallbackRef","useControllableProp","clampValue","countDecimalPlaces","maxSafeInteger","minSafeInteger","toPrecision","useCallback","useState","useCounter","props","onChange","precision","precisionProp","defaultValue","value","valueProp","step","stepProp","min","max","keepWithinRange","onChangeProp","valueState","setValue","_cast","cast","isControlled","decimalPlaces","getDecimalPlaces","parse","update","next","toString","clamp","nextValue","increment","decrement","reset","_cast2","castValue","_cast3","valueAsNumber","isOutOfRange","isAtMax","isAtMin","parseFloat","replace","Math","parsedValue","Number","isNaN","undefined"],"mappings":"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","sourcesContent":["import { useCallbackRef, useControllableProp } from \"@chakra-ui/hooks\";\nimport { clampValue, countDecimalPlaces, maxSafeInteger, minSafeInteger, toPrecision } from \"@chakra-ui/utils\";\nimport { useCallback, useState } from \"react\";\nexport function useCounter(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    keepWithinRange = true\n  } = props;\n  var onChangeProp = useCallbackRef(onChange);\n  var [valueState, setValue] = useState(() => {\n    var _cast;\n\n    if (defaultValue == null) return \"\";\n    return (_cast = cast(defaultValue, stepProp, precisionProp)) != null ? _cast : \"\";\n  });\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n\n  var [isControlled, value] = useControllableProp(valueProp, valueState);\n  var decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  var precision = precisionProp != null ? precisionProp : decimalPlaces;\n  var update = useCallback(next => {\n    if (next === value) return;\n\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n\n    onChangeProp == null ? void 0 : onChangeProp(next.toString(), parse(next));\n  }, [onChangeProp, isControlled, value]); // Function to clamp the value and round it to the precision\n\n  var clamp = useCallback(value => {\n    var nextValue = value;\n\n    if (keepWithinRange) {\n      nextValue = clampValue(nextValue, min, max);\n    }\n\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  var increment = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next;\n    /**\n     * Let's follow the native browser behavior for\n     * scenarios where the input starts empty (\"\")\n     */\n\n    if (value === \"\") {\n      /**\n       * If `min` is set, native input, starts at the `min`.\n       * Else, it starts at `step`\n       */\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  var decrement = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next; // Same thing here. We'll follow native implementation\n\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, stepProp, update, value]);\n  var reset = useCallback(() => {\n    var next;\n\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      var _cast2;\n\n      next = (_cast2 = cast(defaultValue, stepProp, precisionProp)) != null ? _cast2 : min;\n    }\n\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update, min]);\n  var castValue = useCallback(value => {\n    var _cast3;\n\n    var nextValue = (_cast3 = cast(value, stepProp, precision)) != null ? _cast3 : min;\n    update(nextValue);\n  }, [precision, stepProp, update, min]);\n  var valueAsNumber = parse(value);\n  /**\n   * Common range checks\n   */\n\n  var isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  var isAtMax = valueAsNumber === max;\n  var isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue,\n    setValue\n  };\n}\n\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\n\nfunction getDecimalPlaces(value, step) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));\n}\n\nfunction cast(value, step, precision) {\n  var parsedValue = parse(value);\n  if (Number.isNaN(parsedValue)) return undefined;\n  var decimalPlaces = getDecimalPlaces(parsedValue, step);\n  return toPrecision(parsedValue, precision != null ? precision : decimalPlaces);\n}\n//# sourceMappingURL=use-counter.js.map"]},"metadata":{},"sourceType":"module"}