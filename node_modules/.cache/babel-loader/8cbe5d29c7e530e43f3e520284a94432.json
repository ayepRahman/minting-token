{"ast":null,"code":"export function getFirstItem(array) {\n  return array != null && array.length ? array[0] : undefined;\n}\nexport function getLastItem(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\nexport function getPrevItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var prevIndex = getPrevIndex(index, array.length, loop);\n  return array[prevIndex];\n}\nexport function getNextItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var nextIndex = getNextIndex(index, array.length, 1, loop);\n  return array[nextIndex];\n}\nexport function removeIndex(array, index) {\n  return array.filter((_, idx) => idx !== index);\n}\nexport function addItem(array, item) {\n  return [...array, item];\n}\nexport function removeItem(array, item) {\n  return array.filter(eachItem => eachItem !== item);\n}\n/**\n * Get the next index based on the current index and step.\n *\n * @param currentIndex the current index\n * @param length the total length or count of items\n * @param step the number of steps\n * @param loop whether to circle back once `currentIndex` is at the start/end\n */\n\nexport function getNextIndex(currentIndex, length, step, loop) {\n  if (step === void 0) {\n    step = 1;\n  }\n\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var lastIndex = length - 1;\n\n  if (currentIndex === -1) {\n    return step > 0 ? 0 : lastIndex;\n  }\n\n  var nextIndex = currentIndex + step;\n\n  if (nextIndex < 0) {\n    return loop ? lastIndex : 0;\n  }\n\n  if (nextIndex >= length) {\n    if (loop) return 0;\n    return currentIndex > length ? length : currentIndex;\n  }\n\n  return nextIndex;\n}\n/**\n * Get's the previous index based on the current index.\n * Mostly used for keyboard navigation.\n *\n * @param index - the current index\n * @param count - the length or total count of items in the array\n * @param loop - whether we should circle back to the\n * first/last once `currentIndex` is at the start/end\n */\n\nexport function getPrevIndex(index, count, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  return getNextIndex(index, count, -1, loop);\n}\n/**\n * Converts an array into smaller chunks or groups.\n *\n * @param array the array to chunk into group\n * @param size the length of each chunk\n */\n\nexport function chunk(array, size) {\n  return array.reduce((rows, currentValue, index) => {\n    if (index % size === 0) {\n      rows.push([currentValue]);\n    } else {\n      rows[rows.length - 1].push(currentValue);\n    }\n\n    return rows;\n  }, []);\n}\n/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\n\nexport function getNextItemFromSearch(items, searchString, itemToString, currentItem) {\n  if (searchString == null) {\n    return currentItem;\n  } // If current item doesn't exist, find the item that matches the search string\n\n\n  if (!currentItem) {\n    var foundItem = items.find(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));\n    return foundItem;\n  } // Filter items for ones that match the search string (case insensitive)\n\n\n  var matchingItems = items.filter(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())); // If there's a match, let's get the next item to select\n\n  if (matchingItems.length > 0) {\n    var nextIndex; // If the currentItem is in the available items, we move to the next available option\n\n    if (matchingItems.includes(currentItem)) {\n      var currentIndex = matchingItems.indexOf(currentItem);\n      nextIndex = currentIndex + 1;\n\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0;\n      }\n\n      return matchingItems[nextIndex];\n    } // Else, we pick the first item in the available items\n\n\n    nextIndex = items.indexOf(matchingItems[0]);\n    return items[nextIndex];\n  } // a decent fallback to the currentItem\n\n\n  return currentItem;\n}","map":{"version":3,"sources":["/Users/arifrahman/Code/personal/minting-token/client/node_modules/@chakra-ui/utils/dist/esm/array.js"],"names":["getFirstItem","array","length","undefined","getLastItem","getPrevItem","index","loop","prevIndex","getPrevIndex","getNextItem","nextIndex","getNextIndex","removeIndex","filter","_","idx","addItem","item","removeItem","eachItem","currentIndex","step","lastIndex","count","chunk","size","reduce","rows","currentValue","push","getNextItemFromSearch","items","searchString","itemToString","currentItem","foundItem","find","toLowerCase","startsWith","matchingItems","includes","indexOf"],"mappings":"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","sourcesContent":["export function getFirstItem(array) {\n  return array != null && array.length ? array[0] : undefined;\n}\nexport function getLastItem(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\nexport function getPrevItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var prevIndex = getPrevIndex(index, array.length, loop);\n  return array[prevIndex];\n}\nexport function getNextItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var nextIndex = getNextIndex(index, array.length, 1, loop);\n  return array[nextIndex];\n}\nexport function removeIndex(array, index) {\n  return array.filter((_, idx) => idx !== index);\n}\nexport function addItem(array, item) {\n  return [...array, item];\n}\nexport function removeItem(array, item) {\n  return array.filter(eachItem => eachItem !== item);\n}\n/**\n * Get the next index based on the current index and step.\n *\n * @param currentIndex the current index\n * @param length the total length or count of items\n * @param step the number of steps\n * @param loop whether to circle back once `currentIndex` is at the start/end\n */\n\nexport function getNextIndex(currentIndex, length, step, loop) {\n  if (step === void 0) {\n    step = 1;\n  }\n\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var lastIndex = length - 1;\n\n  if (currentIndex === -1) {\n    return step > 0 ? 0 : lastIndex;\n  }\n\n  var nextIndex = currentIndex + step;\n\n  if (nextIndex < 0) {\n    return loop ? lastIndex : 0;\n  }\n\n  if (nextIndex >= length) {\n    if (loop) return 0;\n    return currentIndex > length ? length : currentIndex;\n  }\n\n  return nextIndex;\n}\n/**\n * Get's the previous index based on the current index.\n * Mostly used for keyboard navigation.\n *\n * @param index - the current index\n * @param count - the length or total count of items in the array\n * @param loop - whether we should circle back to the\n * first/last once `currentIndex` is at the start/end\n */\n\nexport function getPrevIndex(index, count, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  return getNextIndex(index, count, -1, loop);\n}\n/**\n * Converts an array into smaller chunks or groups.\n *\n * @param array the array to chunk into group\n * @param size the length of each chunk\n */\n\nexport function chunk(array, size) {\n  return array.reduce((rows, currentValue, index) => {\n    if (index % size === 0) {\n      rows.push([currentValue]);\n    } else {\n      rows[rows.length - 1].push(currentValue);\n    }\n\n    return rows;\n  }, []);\n}\n/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\n\nexport function getNextItemFromSearch(items, searchString, itemToString, currentItem) {\n  if (searchString == null) {\n    return currentItem;\n  } // If current item doesn't exist, find the item that matches the search string\n\n\n  if (!currentItem) {\n    var foundItem = items.find(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));\n    return foundItem;\n  } // Filter items for ones that match the search string (case insensitive)\n\n\n  var matchingItems = items.filter(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())); // If there's a match, let's get the next item to select\n\n  if (matchingItems.length > 0) {\n    var nextIndex; // If the currentItem is in the available items, we move to the next available option\n\n    if (matchingItems.includes(currentItem)) {\n      var currentIndex = matchingItems.indexOf(currentItem);\n      nextIndex = currentIndex + 1;\n\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0;\n      }\n\n      return matchingItems[nextIndex];\n    } // Else, we pick the first item in the available items\n\n\n    nextIndex = items.indexOf(matchingItems[0]);\n    return items[nextIndex];\n  } // a decent fallback to the currentItem\n\n\n  return currentItem;\n}\n//# sourceMappingURL=array.js.map"]},"metadata":{},"sourceType":"module"}